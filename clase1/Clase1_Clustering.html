<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.552">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Untitled</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="Clase1_Clustering_files/libs/clipboard/clipboard.min.js"></script>
<script src="Clase1_Clustering_files/libs/quarto-html/quarto.js"></script>
<script src="Clase1_Clustering_files/libs/quarto-html/popper.min.js"></script>
<script src="Clase1_Clustering_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="Clase1_Clustering_files/libs/quarto-html/anchor.min.js"></script>
<link href="Clase1_Clustering_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="Clase1_Clustering_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="Clase1_Clustering_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="Clase1_Clustering_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="Clase1_Clustering_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="fullcontent">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Untitled</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<section id="prerequisitos" class="level2">
<h2 class="anchored" data-anchor-id="prerequisitos">Prerequisitos</h2>
<ul>
<li>Anaconda (2024.02-1)</li>
<li>R (4.0.0) y Rstudio (2024.04.1+748 | Released: 2024-05-11)</li>
<li>Quarto</li>
<li>Visual Studio code con complmentos de Jupyter Notebook</li>
<li>Los siguientes paquetes de R se requieren:</li>
</ul>
<div class="cell">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(dplyr)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stderr">
<pre><code>
Attaching package: 'dplyr'</code></pre>
</div>
<div class="cell-output cell-output-stderr">
<pre><code>The following objects are masked from 'package:stats':

    filter, lag</code></pre>
</div>
<div class="cell-output cell-output-stderr">
<pre><code>The following objects are masked from 'package:base':

    intersect, setdiff, setequal, union</code></pre>
</div>
<div class="sourceCode cell-code" id="cb5"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(ggplot2)</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(patchwork)</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(reticulate)</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(cluster)</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(factoextra) <span class="co"># Método silhoute</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stderr">
<pre><code>Welcome! Want to learn more? See two factoextra-related books at https://goo.gl/ve3WBa</code></pre>
</div>
<div class="sourceCode cell-code" id="cb7"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(dbscan)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stderr">
<pre><code>
Attaching package: 'dbscan'</code></pre>
</div>
<div class="cell-output cell-output-stderr">
<pre><code>The following object is masked from 'package:stats':

    as.dendrogram</code></pre>
</div>
<div class="sourceCode cell-code" id="cb10"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(klaR) <span class="co"># Para k mediods</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stderr">
<pre><code>Loading required package: MASS</code></pre>
</div>
<div class="cell-output cell-output-stderr">
<pre><code>
Attaching package: 'MASS'</code></pre>
</div>
<div class="cell-output cell-output-stderr">
<pre><code>The following object is masked from 'package:patchwork':

    area</code></pre>
</div>
<div class="cell-output cell-output-stderr">
<pre><code>The following object is masked from 'package:dplyr':

    select</code></pre>
</div>
</div>
</section>
<section id="metodologías-para-número-de-clusters" class="level1">
<h1>Metodologías para número de clusters</h1>
<div class="cell">
<div class="sourceCode cell-code" id="cb15"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a>iris_data <span class="ot">&lt;-</span> iris[,<span class="dv">1</span><span class="sc">:</span><span class="dv">2</span>]</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a><span class="fu">head</span>(iris_data)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>  Sepal.Length Sepal.Width
1          5.1         3.5
2          4.9         3.0
3          4.7         3.2
4          4.6         3.1
5          5.0         3.6
6          5.4         3.9</code></pre>
</div>
</div>
<p>Graficamos esta nube de puntos:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb17"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="fu">ggplot</span>(<span class="at">data =</span> iris_data, <span class="fu">aes</span>(<span class="at">x =</span> Sepal.Length, <span class="at">y =</span> Sepal.Width)) <span class="sc">+</span> <span class="fu">geom_point</span>() <span class="sc">+</span> <span class="fu">theme_bw</span>()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="Clase1_Clustering_files/figure-html/unnamed-chunk-3-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
<section id="método-silhoute" class="level2">
<h2 class="anchored" data-anchor-id="método-silhoute">Método Silhoute</h2>
<p>El algoritmo en R realiza lo siguiente para calcular el coeficiente de silhouette:</p>
<ul>
<li>Para cada observación en el conjunto de datos, se calcula la distancia media al resto de observaciones dentro de su propio clúster (a) y la distancia media al resto de observaciones en el clúster más cercano diferente (b).</li>
<li>El coeficiente de silhouette para cada observación se calcula como (b - a) / max(a, b).</li>
<li>El coeficiente de silhouette promedio para el conjunto de datos se calcula como el promedio de los coeficientes de silhouette individuales.</li>
</ul>
<p>Con este coeficiente podemos encontrar el número óptimo de clusters:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb18"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="fu">fviz_nbclust</span>(iris_data,kmeans, <span class="at">method =</span> <span class="st">"silhouette"</span>,<span class="at">k.max=</span><span class="dv">20</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="Clase1_Clustering_files/figure-html/unnamed-chunk-4-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
</section>
<section id="método-de-distancia-cuadrada-dentro" class="level2">
<h2 class="anchored" data-anchor-id="método-de-distancia-cuadrada-dentro">Método de distancia cuadrada dentro</h2>
<p>La suma de los cuadrados dentro del clúster (WSS) es una medida de cuán cohesivos son los clústeres, es decir, cuán cerca están los puntos dentro de un clúster entre sí. El método de codo consiste en calcular la WSS para diferentes valores de k (número de clústeres) y graficar estos valores en función de k. La idea es identificar el “codo” en la curva, que es el punto donde la WSS comienza a disminuir de manera más lenta. Este punto indica el número óptimo de clústeres, ya que agregar más clústeres a partir de este punto no proporciona una mejora significativa en la cohesión dentro de los clústeres.</p>
<p>Las fórmulas para calcular la WSS son las siguientes:</p>
<p>Para cada clúster <span class="math inline">\(C_i\)</span></p>
<p>Se calcula la distancia cuadrada de cada punto al centroide del clúster <span class="math inline">\(\mu_i\)</span></p>
<p>Se suman estas distancias cuadradas para obtener la WSS del clúster <span class="math inline">\(WSS_i\)</span></p>
<p><span class="math display">\[WSS_i = \sum_{x \in C_i} (x - \mu_i )^2\]</span></p>
<p>No todos los problemas se pueden resolver con kmeans, sino que existen técnicas más apropiadas para detectar de forma más efectiva como se compartan los puntos en un conjunto de datos:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb19"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a>df_shapes <span class="ot">&lt;-</span> <span class="fu">read.csv</span>(<span class="st">"multishapes.csv"</span>) <span class="sc">%&gt;%</span> dplyr<span class="sc">::</span><span class="fu">select</span>(x, y)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Calculamos por k - meadias:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb20"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">12345</span>)</span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a>kmedias <span class="ot">&lt;-</span> <span class="fu">kmeans</span>(df_shapes, <span class="dv">5</span>)</span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a>df_shapes<span class="sc">$</span>grupo_kmedias <span class="ot">&lt;-</span> kmedias<span class="sc">$</span>cluster <span class="sc">%&gt;%</span> <span class="fu">as.character</span>()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>AHora calculamos por el método debscan:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb21"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a>dbscan_method <span class="ot">&lt;-</span> <span class="fu">dbscan</span>(df_shapes <span class="sc">%&gt;%</span> dplyr<span class="sc">::</span><span class="fu">select</span>(x, y), <span class="at">eps =</span> .<span class="dv">15</span>, <span class="at">minPts =</span> <span class="dv">5</span>)</span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a>df_shapes<span class="sc">$</span>grupo_dmscan <span class="ot">&lt;-</span> dbscan_method<span class="sc">$</span>cluster <span class="sc">%&gt;%</span> <span class="fu">as.character</span>()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell">
<div class="sourceCode cell-code" id="cb22"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="fu">table</span>(df_shapes<span class="sc">$</span>grupo_dmscan)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>
  0   1   2   3   4   5 
 31 410 405 104  99  51 </code></pre>
</div>
</div>
<div class="cell">
<div class="sourceCode cell-code" id="cb24"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a>grafico_kmeans <span class="ot">&lt;-</span> <span class="fu">ggplot</span>(<span class="at">data =</span> df_shapes, <span class="fu">aes</span>(x, y, <span class="at">color =</span> grupo_kmedias)) <span class="sc">+</span> <span class="fu">geom_point</span>()</span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a>grafico_dmscan <span class="ot">&lt;-</span> <span class="fu">ggplot</span>(<span class="at">data =</span> df_shapes, <span class="fu">aes</span>(x, y, <span class="at">color =</span> grupo_dmscan)) <span class="sc">+</span> <span class="fu">geom_point</span>()</span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a>grafico_kmeans <span class="sc">+</span> grafico_dmscan</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="Clase1_Clustering_files/figure-html/unnamed-chunk-9-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
<p>En Python podemos resolver de la siguiente manera:</p>
<p>Cargamos los paquetes:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb25"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.model_selection <span class="im">import</span> train_test_split</span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.cluster <span class="im">import</span> DBSCAN</span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> collections <span class="im">import</span> Counter</span>
<span id="cb25-5"><a href="#cb25-5" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.datasets <span class="im">import</span> make_blobs</span>
<span id="cb25-6"><a href="#cb25-6" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Traemos unos datos para desarrollar elmétodo debscan en Python:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb26"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a><span class="co"># Read the CSV file</span></span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a>df_shapes <span class="op">=</span> pd.read_csv(<span class="st">"multishapes.csv"</span>)</span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-5"><a href="#cb26-5" aria-hidden="true" tabindex="-1"></a><span class="co"># Select columns 'x' and 'y'</span></span>
<span id="cb26-6"><a href="#cb26-6" aria-hidden="true" tabindex="-1"></a>df_shapes <span class="op">=</span> df_shapes[[<span class="st">'x'</span>, <span class="st">'y'</span>]]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Calculamos el método dbscan:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb27"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a>dbscan_method <span class="op">=</span> DBSCAN(eps <span class="op">=</span> <span class="fl">0.15</span>, min_samples <span class="op">=</span> <span class="dv">5</span>, metric <span class="op">=</span> <span class="st">'euclidean'</span>)</span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a>plt.scatter(df_shapes.iloc[:,<span class="dv">0</span>], df_shapes.iloc[:,<span class="dv">1</span>], c <span class="op">=</span> dbscan_method.fit_predict(df_shapes))</span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">'Toy Problem with Minimum Points: '</span> <span class="op">+</span> <span class="bu">str</span>(<span class="dv">5</span>))</span>
<span id="cb27-4"><a href="#cb27-4" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="Clase1_Clustering_files/figure-html/unnamed-chunk-12-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
<p>EL -1 hace referencia al grupo de outliers:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb28"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a>labels <span class="op">=</span> dbscan_method.fit_predict(df_shapes)</span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a>Counter(labels)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Counter({0: 410, 1: 405, 2: 104, 3: 99, 4: 51, -1: 31})</code></pre>
</div>
</div>
<p>Ilustraremos el método para diferentes valores de epsilon:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb30"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a>XX, yy <span class="op">=</span> make_blobs(n_samples<span class="op">=</span><span class="dv">1000</span>, centers<span class="op">=</span><span class="dv">8</span>, n_features<span class="op">=</span><span class="dv">2</span>, random_state<span class="op">=</span><span class="dv">800</span>)</span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a><span class="co"># Visualize the data</span></span>
<span id="cb30-3"><a href="#cb30-3" aria-hidden="true" tabindex="-1"></a>plt.scatter(XX[:,<span class="dv">0</span>], XX[:,<span class="dv">1</span>])</span>
<span id="cb30-4"><a href="#cb30-4" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="Clase1_Clustering_files/figure-html/unnamed-chunk-14-3.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
<div class="cell">
<div class="sourceCode cell-code" id="cb31"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a>num_samples <span class="op">=</span> [<span class="dv">10</span>,<span class="dv">19</span>,<span class="dv">20</span>]</span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-3"><a href="#cb31-3" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> min_num <span class="kw">in</span> num_samples:</span>
<span id="cb31-4"><a href="#cb31-4" aria-hidden="true" tabindex="-1"></a>    db <span class="op">=</span> DBSCAN(eps<span class="op">=</span><span class="fl">0.7</span>, min_samples<span class="op">=</span>min_num, metric<span class="op">=</span><span class="st">'euclidean'</span>)</span>
<span id="cb31-5"><a href="#cb31-5" aria-hidden="true" tabindex="-1"></a>    plt.scatter(XX[:,<span class="dv">0</span>], XX[:,<span class="dv">1</span>], c<span class="op">=</span>db.fit_predict(XX))</span>
<span id="cb31-6"><a href="#cb31-6" aria-hidden="true" tabindex="-1"></a>    plt.title(<span class="st">'Toy Problem with Minimum Points: '</span> <span class="op">+</span> <span class="bu">str</span>(min_num))</span>
<span id="cb31-7"><a href="#cb31-7" aria-hidden="true" tabindex="-1"></a>    plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="Clase1_Clustering_files/figure-html/unnamed-chunk-15-5.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="Clase1_Clustering_files/figure-html/unnamed-chunk-15-6.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="Clase1_Clustering_files/figure-html/unnamed-chunk-15-7.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
<p>Observemos como varía el radio:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb32"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a>epsilons <span class="op">=</span> [<span class="fl">0.4</span>,<span class="fl">0.7</span>]</span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-3"><a href="#cb32-3" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> epsilon <span class="kw">in</span> epsilons:</span>
<span id="cb32-4"><a href="#cb32-4" aria-hidden="true" tabindex="-1"></a>    db <span class="op">=</span> DBSCAN(eps<span class="op">=</span>epsilon, min_samples<span class="op">=</span><span class="dv">10</span>, metric<span class="op">=</span><span class="st">'euclidean'</span>)</span>
<span id="cb32-5"><a href="#cb32-5" aria-hidden="true" tabindex="-1"></a>    plt.scatter(XX[:,<span class="dv">0</span>], XX[:,<span class="dv">1</span>], c<span class="op">=</span>db.fit_predict(XX))</span>
<span id="cb32-6"><a href="#cb32-6" aria-hidden="true" tabindex="-1"></a>    plt.title(<span class="st">'Toy Problem with Minimum Points: '</span> <span class="op">+</span> <span class="bu">str</span>(epsilon))</span>
<span id="cb32-7"><a href="#cb32-7" aria-hidden="true" tabindex="-1"></a>    plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="Clase1_Clustering_files/figure-html/unnamed-chunk-16-11.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="Clase1_Clustering_files/figure-html/unnamed-chunk-16-12.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
<p>Podemos también entrenar el modelo para cuando lleguen nuevos datos:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb33"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Assuming your data has features 'x' and 'y', select those columns</span></span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-3"><a href="#cb33-3" aria-hidden="true" tabindex="-1"></a><span class="co"># Split the data into training and testing sets</span></span>
<span id="cb33-4"><a href="#cb33-4" aria-hidden="true" tabindex="-1"></a>X_train, X_test <span class="op">=</span> train_test_split(df_shapes, test_size<span class="op">=</span><span class="fl">0.2</span>, random_state<span class="op">=</span><span class="dv">12345</span>)</span>
<span id="cb33-5"><a href="#cb33-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-6"><a href="#cb33-6" aria-hidden="true" tabindex="-1"></a><span class="co"># Initialize DBSCAN model</span></span>
<span id="cb33-7"><a href="#cb33-7" aria-hidden="true" tabindex="-1"></a>dbscan <span class="op">=</span> DBSCAN(eps<span class="op">=</span><span class="fl">0.15</span>, min_samples<span class="op">=</span><span class="dv">5</span>)</span>
<span id="cb33-8"><a href="#cb33-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-9"><a href="#cb33-9" aria-hidden="true" tabindex="-1"></a><span class="co"># Train the model</span></span>
<span id="cb33-10"><a href="#cb33-10" aria-hidden="true" tabindex="-1"></a>dbscan.fit(X_train)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<style>#sk-container-id-1 {color: black;background-color: white;}#sk-container-id-1 pre{padding: 0;}#sk-container-id-1 div.sk-toggleable {background-color: white;}#sk-container-id-1 label.sk-toggleable__label {cursor: pointer;display: block;width: 100%;margin-bottom: 0;padding: 0.3em;box-sizing: border-box;text-align: center;}#sk-container-id-1 label.sk-toggleable__label-arrow:before {content: "▸";float: left;margin-right: 0.25em;color: #696969;}#sk-container-id-1 label.sk-toggleable__label-arrow:hover:before {color: black;}#sk-container-id-1 div.sk-estimator:hover label.sk-toggleable__label-arrow:before {color: black;}#sk-container-id-1 div.sk-toggleable__content {max-height: 0;max-width: 0;overflow: hidden;text-align: left;background-color: #f0f8ff;}#sk-container-id-1 div.sk-toggleable__content pre {margin: 0.2em;color: black;border-radius: 0.25em;background-color: #f0f8ff;}#sk-container-id-1 input.sk-toggleable__control:checked~div.sk-toggleable__content {max-height: 200px;max-width: 100%;overflow: auto;}#sk-container-id-1 input.sk-toggleable__control:checked~label.sk-toggleable__label-arrow:before {content: "▾";}#sk-container-id-1 div.sk-estimator input.sk-toggleable__control:checked~label.sk-toggleable__label {background-color: #d4ebff;}#sk-container-id-1 div.sk-label input.sk-toggleable__control:checked~label.sk-toggleable__label {background-color: #d4ebff;}#sk-container-id-1 input.sk-hidden--visually {border: 0;clip: rect(1px 1px 1px 1px);clip: rect(1px, 1px, 1px, 1px);height: 1px;margin: -1px;overflow: hidden;padding: 0;position: absolute;width: 1px;}#sk-container-id-1 div.sk-estimator {font-family: monospace;background-color: #f0f8ff;border: 1px dotted black;border-radius: 0.25em;box-sizing: border-box;margin-bottom: 0.5em;}#sk-container-id-1 div.sk-estimator:hover {background-color: #d4ebff;}#sk-container-id-1 div.sk-parallel-item::after {content: "";width: 100%;border-bottom: 1px solid gray;flex-grow: 1;}#sk-container-id-1 div.sk-label:hover label.sk-toggleable__label {background-color: #d4ebff;}#sk-container-id-1 div.sk-serial::before {content: "";position: absolute;border-left: 1px solid gray;box-sizing: border-box;top: 0;bottom: 0;left: 50%;z-index: 0;}#sk-container-id-1 div.sk-serial {display: flex;flex-direction: column;align-items: center;background-color: white;padding-right: 0.2em;padding-left: 0.2em;position: relative;}#sk-container-id-1 div.sk-item {position: relative;z-index: 1;}#sk-container-id-1 div.sk-parallel {display: flex;align-items: stretch;justify-content: center;background-color: white;position: relative;}#sk-container-id-1 div.sk-item::before, #sk-container-id-1 div.sk-parallel-item::before {content: "";position: absolute;border-left: 1px solid gray;box-sizing: border-box;top: 0;bottom: 0;left: 50%;z-index: -1;}#sk-container-id-1 div.sk-parallel-item {display: flex;flex-direction: column;z-index: 1;position: relative;background-color: white;}#sk-container-id-1 div.sk-parallel-item:first-child::after {align-self: flex-end;width: 50%;}#sk-container-id-1 div.sk-parallel-item:last-child::after {align-self: flex-start;width: 50%;}#sk-container-id-1 div.sk-parallel-item:only-child::after {width: 0;}#sk-container-id-1 div.sk-dashed-wrapped {border: 1px dashed gray;margin: 0 0.4em 0.5em 0.4em;box-sizing: border-box;padding-bottom: 0.4em;background-color: white;}#sk-container-id-1 div.sk-label label {font-family: monospace;font-weight: bold;display: inline-block;line-height: 1.2em;}#sk-container-id-1 div.sk-label-container {text-align: center;}#sk-container-id-1 div.sk-container {/* jupyter's `normalize.less` sets `[hidden] { display: none; }` but bootstrap.min.css set `[hidden] { display: none !important; }` so we also need the `!important` here to be able to override the default hidden behavior on the sphinx rendered scikit-learn.org. See: https://github.com/scikit-learn/scikit-learn/issues/21755 */display: inline-block !important;position: relative;}#sk-container-id-1 div.sk-text-repr-fallback {display: none;}</style><div id="sk-container-id-1" class="sk-top-container"><div class="sk-text-repr-fallback"><pre>DBSCAN(eps=0.15)</pre><b>In a Jupyter environment, please rerun this cell to show the HTML representation or trust the notebook. <br>On GitHub, the HTML representation is unable to render, please try loading this page with nbviewer.org.</b></div><div class="sk-container" hidden=""><div class="sk-item"><div class="sk-estimator sk-toggleable"><input class="sk-toggleable__control sk-hidden--visually" id="sk-estimator-id-1" type="checkbox" checked=""><label for="sk-estimator-id-1" class="sk-toggleable__label sk-toggleable__label-arrow">DBSCAN</label><div class="sk-toggleable__content"><pre>DBSCAN(eps=0.15)</pre></div></div></div></div></div>
</div>
<div class="sourceCode cell-code" id="cb34"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Predict cluster labels for the test data</span></span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true" tabindex="-1"></a>test_labels <span class="op">=</span> dbscan.fit_predict(X_test)</span>
<span id="cb34-3"><a href="#cb34-3" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(test_labels)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[ 5 -1 -1 -1 -1  0  1  1  1  5  2  3  1  1  3  1  6 -1 -1  1  4 -1  1  1
 -1  2 -1 -1  1  2 -1 -1  5 -1 -1 -1  1  7  4  8 -1 -1  1  1  1  3 -1 -1
 -1 -1  8 -1  3  7 -1  1  1  3 -1 -1 -1 -1 -1  1  1 -1 -1 -1  1 -1  6 -1
  1  3  1  1  1  1  2  1  1  6  2 -1  1 -1 -1  4 -1  1  6  8 -1 -1 -1  8
  1  1 -1  3 -1  1  0  1  1 -1  1 -1  0  5  1  1  1 -1 -1  1 -1  1 -1  1
  3  7  3 -1  0 -1 -1  1  1 -1  6  1 -1  1  1  0  2 -1  1 -1 -1  1 -1  3
 -1 -1  1 -1  2  4  1  1  7  1  1 -1  1  5 -1 -1 -1 -1 -1  1  1 -1 -1 -1
  1  1  1  5 -1  1  1 -1  6 -1 -1  1  1  6  7 -1  5 -1 -1  1  1  3  1  8
 -1  1 -1  1  1  1 -1  1  1 -1 -1  3  1  4 -1  5  2 -1  1  1 -1  1 -1  2
  1 -1 -1  5]</code></pre>
</div>
</div>
<div class="cell">
<div class="sourceCode cell-code" id="cb36"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a>plt.scatter(X_test.iloc[:,<span class="dv">0</span>], X_test.iloc[:,<span class="dv">1</span>],</span>
<span id="cb36-2"><a href="#cb36-2" aria-hidden="true" tabindex="-1"></a>            c <span class="op">=</span> dbscan_method.fit_predict(X_test))</span>
<span id="cb36-3"><a href="#cb36-3" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">'Toy Problem with Minimum Points: '</span> <span class="op">+</span> <span class="bu">str</span>(<span class="dv">5</span>))</span>
<span id="cb36-4"><a href="#cb36-4" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="Clase1_Clustering_files/figure-html/unnamed-chunk-18-15.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
</section>
</section>
<section id="método-dbscan" class="level1">
<h1>Método DBSCAN</h1>
<p>DBSCAN (Density-Based Spatial Clustering of Applications with Noise) es un algoritmo de clustering basado en densidad. Fue propuesto por Martin Ester, Hans-Peter Kriegel, Jörg Sander y Xiaowei Xu en 1996. El algoritmo tiene como objetivo descubrir clusters de forma arbitraria en un espacio de datos basado en la densidad de los puntos de datos.</p>
<section id="componentes-y-parámetros-clave" class="level2">
<h2 class="anchored" data-anchor-id="componentes-y-parámetros-clave">Componentes y Parámetros Clave</h2>
<p>Epsilon (ε): Radio máximo de un vecindario de un punto. Este parámetro define qué tan cerca deben estar los puntos para ser considerados vecinos. MinPts: Número mínimo de puntos que deben estar en un vecindario para que un punto sea considerado un punto central (core point).</p>
<p><img src="images/clipboard-2074857476.png" class="img-fluid"></p>
<p>Un vecindario de un punto se define como la región circular con ese punto como el centro y un radio de Epsilon. Cada punto en el conjunto de datos se clasifica en una de las siguientes categorías:</p>
<p>Punto central (Core point): Si hay al menos MinPoints en el vecindario. Punto de borde (Border point): Si este punto se encuentra en el vecindario de un punto central y tiene menos de MinPoints en su propio vecindario. Punto atípico (Outlier point): Tiene menos de MinPoints en su propio vecindario y no tiene ningún otro punto central en su vecindario. Todos los puntos centrales llevan a la formación de un cluster. Si dos clusters tienen 2 o más puntos centrales en su vecindario mutuo, esos clusters se fusionan. Después de este proceso iterativo, nos quedamos con clusters y puntos atípicos.</p>
<p>Esta técnica no depende de inicializaciones aleatorias como lo hace K-means, ya que su enfoque se basa en la densidad de los puntos en el espacio de características.</p>
<p><img src="images/clipboard-1614325023.png" class="img-fluid"></p>
<p><img src="images/clipboard-2717180202.png" class="img-fluid"></p>
<p>Ejemplo de diferentes distancias:</p>
<p><img src="images/clipboard-1426748174.png" class="img-fluid"></p>
<p>DBSCAN (Density-Based Spatial Clustering of Applications with Noise) es útil en situaciones del mundo real en las que los datos tienen una distribución espacial irregular y pueden contener ruido o valores atípicos. Aquí hay algunos escenarios comunes en los negocios y el mundo real donde DBSCAN puede ser preferible sobre K-means:</p>
<p>Detección de anomalías: DBSCAN puede identificar puntos de datos atípicos o ruidosos que no se ajustan a ningún grupo particular. Esto es útil en la detección de fraudes en transacciones financieras, identificación de comportamientos inusuales en sistemas de monitoreo de red, o detectar errores en datos de sensores.</p>
<p>Agrupación de densidad variable: A diferencia de K-means, DBSCAN puede identificar agrupaciones de diferentes formas y tamaños, sin necesidad de especificar el número de clústeres de antemano. Esto es beneficioso en aplicaciones donde los clústeres pueden tener densidades variables o formas irregulares, como la segmentación de clientes en marketing o la agrupación de patrones en datos de imágenes.</p>
<p>Manejo de datos ruidosos: DBSCAN es robusto frente a datos ruidosos y no sensibles a la inicialización de los centroides. Esto lo hace adecuado para conjuntos de datos con ruido o valores atípicos, donde K-means podría verse afectado negativamente por la presencia de estos valores.</p>
<p>Eficiencia computacional: DBSCAN tiene una complejidad de tiempo de ejecución mejor que K-means para conjuntos de datos grandes, ya que no requiere calcular la distancia entre todos los pares de puntos. Esto lo hace más adecuado para aplicaciones de big data o en entornos donde la eficiencia computacional es crucial.</p>
</section>
<section id="k---mediodes" class="level2">
<h2 class="anchored" data-anchor-id="k---mediodes">K - mediodes</h2>
<p>El método de K-modes es una extensión del algoritmo K-means, diseñado específicamente para manejar datos categóricos. A diferencia de K-means, que se basa en la distancia euclidiana y requiere datos numéricos, K-modes utiliza una medida de disimilitud para trabajar con datos categóricos.</p>
<p>Ventajas de K-modes Manejo de Datos Categóricos:</p>
<p>K-modes está diseñado específicamente para datos categóricos, lo que lo hace más adecuado que K-means para este tipo de datos. Simplicidad y Eficiencia:</p>
<p>Similar a K-means, el algoritmo K-modes es simple y eficiente, escalando bien con conjuntos de datos grandes. Interpretabilidad:</p>
<p>Los modos (centroides) resultantes son fácilmente interpretables, ya que consisten en valores categóricos representativos de los clústeres.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb37"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a>df_cancer <span class="ot">&lt;-</span> <span class="fu">read.csv</span>(<span class="st">"breast_cancer.csv"</span>, <span class="at">header =</span> <span class="cn">FALSE</span>) <span class="sc">%&gt;%</span> <span class="fu">as_tibble</span>()</span>
<span id="cb37-2"><a href="#cb37-2" aria-hidden="true" tabindex="-1"></a><span class="fu">names</span>(df_cancer) <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="st">"class"</span>, <span class="st">"age"</span>, <span class="st">"mefalsepause"</span>, <span class="st">"tumor_size"</span>, <span class="st">"inv-falsedes"</span>,</span>
<span id="cb37-3"><a href="#cb37-3" aria-hidden="true" tabindex="-1"></a>                      <span class="st">"falsede-caps"</span>, <span class="st">"deg_malig"</span>, <span class="st">"breast"</span>, <span class="st">"breast_quad"</span>, <span class="st">"irradiat"</span>) </span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Este conjunto de datos captura diversas características demográficas, patológicas y relacionadas con el tratamiento de los pacientes con cáncer de mama, que pueden ser utilizadas para análisis y potencialmente para predecir resultados de recurrencia.</p>
<p>class (clase) Descripción: Indica si el paciente experimentó una recurrencia del cáncer de mama o no. Valores: “no-recurrence-events” (sin eventos de recurrencia): El paciente no experimentó recurrencia. “recurrence-events” (eventos de recurrencia): El paciente experimentó recurrencia.</p>
<p>age (edad) Descripción: El rango de edad del paciente. Valores: “30-39”: La edad del paciente está entre 30 y 39 años. “40-49”: La edad del paciente está entre 40 y 49 años. “50-59”: La edad del paciente está entre 50 y 59 años. “60-69”: La edad del paciente está entre 60 y 69 años. “70-79”: La edad del paciente está entre 70 y 79 años.</p>
<p>menopause (menopausia): Descripción: Estado menopáusico del paciente. Valores: “premeno” (premenopáusica): El paciente es premenopáusico. “ge40” (mayor o igual a 40): El paciente tiene 40 años o más y es menopáusico. “lt40” (menor de 40): El paciente tiene menos de 40 años y es menopáusico.</p>
<p>tumor_size (tamaño del tumor): Descripción: El tamaño del tumor en milímetros. Valores: Rangos como “0-4”, “5-9”, “10-14”, “15-19”, “20-24”, “25-29”, “30-34”, “35-39”, “40-44”, “45-49”, “50-54”, “55-59”.</p>
<p>inv_nodes (nodos invadidos): Descripción: El número de ganglios linfáticos axilares positivos detectados (indicativo de propagación). Valores: Rangos como “0-2”, “3-5”, “6-8”, “9-11”, “12-14”, “15-17”, “18-20”, “21-23”, “24-26”, “27-29”, “30-32”, “33-35”, “36-39”.</p>
<p>node_caps (cápsula del nodo): Descripción: Presencia de ganglios linfáticos cancerosos más allá de la cápsula. Valores: “no”: No hay ganglios cancerosos más allá de la cápsula. “yes” (sí): Hay ganglios cancerosos más allá de la cápsula.</p>
<p>deg_malig (grado de malignidad): Descripción: Grado de malignidad del tumor, que representa cuán agresivas son las células cancerosas. Valores: 1: Menos agresivo. 2: Moderadamente agresivo. 3: Más agresivo.</p>
<p>breast (mama): Descripción: La mama en la que se detectó el cáncer. Valores: “left” (izquierda): El cáncer se detectó en la mama izquierda. “right” (derecha): El cáncer se detectó en la mama derecha.</p>
<p>breast_quad (cuadrante de la mama): Descripción: El cuadrante de la mama donde se ubicó el tumor. Valores: “left_up” (superior izquierda): Cuadrante superior izquierdo. “left_low” (inferior izquierda): Cuadrante inferior izquierdo. “right_up” (superior derecha): Cuadrante superior derecho. “right_low” (inferior derecha): Cuadrante inferior derecho. “central” (central): Cuadrante central.</p>
<p>irradiat (irradiación): Descripción: Indica si el paciente recibió radioterapia. Valores: “no”: El paciente no recibió radioterapia. “yes” (sí): El paciente recibió radioterapia.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb38"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a>df_cancer2 <span class="ot">&lt;-</span> df_cancer[,<span class="dv">2</span><span class="sc">:</span><span class="dv">10</span>]</span>
<span id="cb38-2"><a href="#cb38-2" aria-hidden="true" tabindex="-1"></a><span class="fu">head</span>(df_cancer2)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code># A tibble: 6 × 9
  age   mefalsepause tumor_size `inv-falsedes` `falsede-caps` deg_malig breast
  &lt;chr&gt; &lt;chr&gt;        &lt;chr&gt;      &lt;chr&gt;          &lt;chr&gt;              &lt;int&gt; &lt;chr&gt; 
1 30-39 premeno      30-34      0-2            no                     3 left  
2 40-49 premeno      20-24      0-2            no                     2 right 
3 40-49 premeno      20-24      0-2            no                     2 left  
4 60-69 ge40         15-19      0-2            no                     2 right 
5 40-49 premeno      0-4        0-2            no                     2 right 
6 60-69 ge40         15-19      0-2            no                     2 left  
# ℹ 2 more variables: breast_quad &lt;chr&gt;, irradiat &lt;chr&gt;</code></pre>
</div>
</div>
<p>Utilizamos k-mediodides:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb40"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true" tabindex="-1"></a>k.centers <span class="ot">&lt;-</span> <span class="fu">kmodes</span>(df_cancer2, <span class="dv">2</span>, <span class="at">iter.max =</span> <span class="dv">100</span>)</span>
<span id="cb40-2"><a href="#cb40-2" aria-hidden="true" tabindex="-1"></a>k.centers</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>K-modes clustering with 2 clusters of sizes 148, 138

Cluster modes:
    age mefalsepause tumor_size inv-falsedes falsede-caps deg_malig breast
1 40-49      premeno      30-34          0-2           no         2  right
2 50-59         ge40      25-29          0-2           no         3   left
  breast_quad irradiat
1     left_up       no
2    left_low       no

Clustering vector:
  [1] 2 1 1 1 1 2 2 2 1 1 2 2 2 2 1 2 1 2 2 1 2 2 1 1 1 1 2 2 1 2 2 1 2 1 2 1 2
 [38] 2 1 1 2 2 2 1 2 2 1 1 1 1 2 1 2 2 1 2 2 2 1 1 1 1 2 1 1 1 1 2 2 2 2 1 1 1
 [75] 1 2 2 2 2 1 2 2 2 2 1 2 2 2 2 1 1 2 2 1 2 1 1 1 1 2 2 2 1 1 1 1 1 1 1 1 2
[112] 2 1 1 1 1 2 2 1 2 2 1 2 2 2 2 1 1 1 1 1 1 1 2 2 1 1 1 1 1 2 2 2 1 2 1 1 2
[149] 2 1 2 2 2 1 1 1 2 2 1 1 1 1 1 1 2 1 1 1 1 1 1 2 1 1 2 1 2 2 1 1 1 1 1 2 2
[186] 1 2 2 1 1 1 1 2 1 1 2 1 1 2 2 2 2 2 2 2 1 2 2 2 1 1 2 1 1 1 1 2 1 1 1 2 1
[223] 2 2 2 2 2 1 2 1 1 1 1 2 1 2 1 1 2 1 2 2 2 2 1 1 2 2 2 2 1 1 1 2 1 1 1 1 2
[260] 1 2 2 2 2 2 2 1 2 2 2 2 2 1 1 1 1 2 2 1 2 2 1 1 1 2 2

Within cluster simple-matching distance by cluster:
[1] 500 482

Available components:
[1] "cluster"    "size"       "modes"      "withindiff" "iterations"
[6] "weighted"  </code></pre>
</div>
</div>
</section>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>